The plan is to rewrite the planet code with C++ and GLSL, once I've learned some more of it. This code will have to be fast, and I think it'll be good practice.

So this is what it will hopefully work like:

The planetary terrain is generated by a cubesphere. Each face is then subdivided into a predetermined amount of chunks.
Each of these chunks are scaled dynamically using a Quadtree based on the player's relative position.

They each hold their part of the height- and normalmap, which is saved in RAM (at multiple lod levels maybe?).
These chunks are indexed based on their face and position.

This should be implementable by storing the local two-dimensional coordinates using two integers/shorts for each quad.
These could then directly be used to sample the height- and normalmap and you should be able to calculate the vertices
by interpolating the chunk's base quad. This could reduce performance but it will also vastly reduce memory usage,
as storing the vertices for each quad uses 96 bytes (4 Vector3s, each of which holds 3 doubles),
whereas storing them in 2 shorts would only be 4 bytes (2 integers would be 8, still much less).
The size of the quad could be calculated using it's depth (the width/height would be 2^(maxDepth - n) + 1).
